
import os, random as r
from .models import *
from datetime import datetime
from django.conf import settings

# makes new file and stores sql script inside

def genSqlFile(schema, statement):
    filePath = os.path.join(settings.MEDIA_ROOT, f'{schema.name}.sql')
    with open(filePath, 'w') as sqlFile:
        sqlFile.write(statement)
        sqlFile.close()

# orders tables in a consumable manner for the sql to execute properly

def getOrderedTableList(schema):
    tables = []
    for table in Table.objects.filter(schema=schema):
        association = Association.objects.exclude(type='many to many').filter(table2=table)
        if len(association):
            tables.append(table)
        else:
            tables.insert(0, table)
    return tables

# structures association tables for pg database, used in 'genDbStructure'

def genAssociationStructure(schema):
    statement = ''
    for table in Table.objects.filter(schema=schema):
        for association in Association.objects.filter(table1=table, type='many to many'):
            statement += f'CREATE TABLE public.{table.name}_{association.table2.name} (\n\t'
            statement += 'id integer GENERATED BY DEFAULT AS IDENTITY,\n\t'
            statement += f'{table.name}_id integer REFERENCES public.{table.name}(id),\n\t'
            statement += f'{association.table2.name}_id integer REFERENCES public.{association.table2.name}(id),\n\t'
            statement += 'PRIMARY KEY(id)\n);\n\n'
    return statement

# structures basic database using script string

def genDbStructure(schema):
    statement = f'\n--\n-- PostgreSQL database dump for \'{schema.name}\' database\n--\n\n-- Created {datetime.now().date()} on https://www.dummydatabases.com\n\n'
    for table in getOrderedTableList(schema):
        statement += f'CREATE TABLE public.{table.name} (\n\t'
        fieldsStr = 'id integer GENERATED BY DEFAULT AS IDENTITY,\n\t'
        for field in Field.objects.filter(table=table):
            fieldsStr += f'{field.name} '
            if field.dataType == 'TEXT':
                fieldType = f'varchar({field.options["randomOptions"]["length"]["max"]})'
            elif field.dataType == 'INTEGER':
                fieldType = 'integer'
            elif field.dataType == 'REAL':
                fieldType = 'real'
            elif field.dataType == 'DATETIME':
                fieldType = 'date'
            else:
                fieldType = 'integer'
            fieldsStr += f'{fieldType},\n\t'
        fieldsStr += 'PRIMARY KEY(id),\n\t'
        for association in Association.objects.filter(table2=table, type='one to many'):
            fieldsStr += f'{association.table1.name}_id integer REFERENCES public.{association.table1.name}(id),\n\t'
        fieldsStr = f'{fieldsStr[:-3]}\n'
        statement += fieldsStr
        statement += f');\n\n'
    statement += genAssociationStructure(schema)
    return statement

# writes query and data for associations, randomly

def genAssociationData(schema):
    statement = ''
    manyToMany = False
    for table in getOrderedTableList(schema):
        for association in Association.objects.filter(table1=table, type='many to many'):
            manyToMany = True
            statement += f'INSERT INTO public.{table.name}_{association.table2.name} ({table.name}_id, {association.table2.name}_id) VALUES\n\t'
            for rw in range(association.rowCount):
                statement += f'({r.randint(1, table.rowCount)}, {r.choice(range(1, association.table2.rowCount + 1))}),\n\t'
        if manyToMany:
            statement = f'{statement[:-3]};\n\n'
        for association in Association.objects.filter(table2=table, type='one to many'):
            for rw in range(1, table.rowCount + 1):
                statement += f'UPDATE ONLY public.{table.name} SET {association.table1.name}_id = {r.randint(1, association.table1.rowCount)} WHERE id = {rw};\n'
    return statement

# writes query to send data to database (only random for now)

def genDbData(schema, data):
    statement = ''
    for tableName, tableData in data.items():
        subStatement = f'INSERT INTO public.{tableName} ('
        fieldsStr = ''
        fieldData = []
        for fieldName, fieldDatum in tableData.items():
            fieldsStr += f'{fieldName}, '
            fieldData.append(fieldDatum)
        fieldsStr = fieldsStr[:-2] + ')'
        valuesStr = ' VALUES\n'
        for indx in range(len(fieldData[0])):
            newData = [ d[indx] for d in fieldData ]
            values = ''
            for value in newData:
                if str(type(value)) == '<class \'str\'>' | '<class \'datetime.datetime\'>':
                    if str(type(value)) == '<class \'datetime.datetime\'>':
                        value = datetime.date(value)
                    values += f'\'{value}\', '
                elif str(type(value)) == '<class \'int\'>' | '<class \'float\'>':
                    values += f'{value}, '
                else:
                    values += f'\'{value}\', '
            values = values[:-2]
            valuesStr += f'\t({values}),\n'
        valuesStr = f'{valuesStr[:-2]};\n\n'
        subStatement += fieldsStr
        subStatement += valuesStr
        statement += subStatement
    statement += genAssociationData(schema)
    return statement

# uses above functions to create new file with given structure and data

def generatePgFile(schema, tableData):
    statement = genDbStructure(schema)
    statement += genDbData(schema, tableData)
    genSqlFile(schema, statement)
